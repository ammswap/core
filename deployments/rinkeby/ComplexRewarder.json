{
  "address": "0x93C437337a71B8a7fb3090EB640D576CdF5f93C1",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "_rewardToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_tokenPerBlock",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_MASTERCHEF_V2",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [],
      "name": "LogInit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "pid",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "LogOnReward",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "pid",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "allocPoint",
          "type": "uint256"
        }
      ],
      "name": "LogPoolAddition",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "pid",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "allocPoint",
          "type": "uint256"
        }
      ],
      "name": "LogSetPool",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "pid",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "lastRewardBlock",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "lpSupply",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "accRewardPerShare",
          "type": "uint256"
        }
      ],
      "name": "LogUpdatePool",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "allocPoint",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_pid",
          "type": "uint256"
        }
      ],
      "name": "add",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "claimOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "pids",
          "type": "uint256[]"
        }
      ],
      "name": "massUpdatePools",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "pid",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lpToken",
          "type": "uint256"
        }
      ],
      "name": "onTokenReward",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pendingOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_pid",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        }
      ],
      "name": "pendingToken",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "pending",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "pid",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "pendingTokens",
      "outputs": [
        {
          "internalType": "contract IERC20[]",
          "name": "rewardTokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "rewardAmounts",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "poolIds",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "poolInfo",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "accRewardPerShare",
          "type": "uint128"
        },
        {
          "internalType": "uint64",
          "name": "lastRewardBlock",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "allocPoint",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "poolLength",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "pools",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_pid",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_allocPoint",
          "type": "uint256"
        }
      ],
      "name": "set",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "tokenPerBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "direct",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "renounce",
          "type": "bool"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "pid",
          "type": "uint256"
        }
      ],
      "name": "updatePool",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint128",
              "name": "accRewardPerShare",
              "type": "uint128"
            },
            {
              "internalType": "uint64",
              "name": "lastRewardBlock",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "allocPoint",
              "type": "uint64"
            }
          ],
          "internalType": "struct ComplexRewarder.PoolInfo",
          "name": "pool",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "userInfo",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "rewardDebt",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xb9365648e8fd982ac798c9bd457bdb4a444bfc3224387f7b4b0527ee62598807",
  "receipt": {
    "to": null,
    "from": "0xAFd46E9B7E6f44F275b2082fdfC73C017B80617e",
    "contractAddress": "0x93C437337a71B8a7fb3090EB640D576CdF5f93C1",
    "transactionIndex": 4,
    "gasUsed": "1404100",
    "logsBloom": "0x00000000000000000004000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000000000800000000000000020001040000000000400000000000000000000000000000000000000080000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x35862d92d7e5d592cf7af682f7febc3f5e52fdd0fd995629f6c878c0f325e4a9",
    "transactionHash": "0xb9365648e8fd982ac798c9bd457bdb4a444bfc3224387f7b4b0527ee62598807",
    "logs": [
      {
        "transactionIndex": 4,
        "blockNumber": 9387721,
        "transactionHash": "0xb9365648e8fd982ac798c9bd457bdb4a444bfc3224387f7b4b0527ee62598807",
        "address": "0x93C437337a71B8a7fb3090EB640D576CdF5f93C1",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000afd46e9b7e6f44f275b2082fdfc73c017b80617e"
        ],
        "data": "0x",
        "logIndex": 3,
        "blockHash": "0x35862d92d7e5d592cf7af682f7febc3f5e52fdd0fd995629f6c878c0f325e4a9"
      }
    ],
    "blockNumber": 9387721,
    "cumulativeGasUsed": "1763296",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x27f29138978365CCc4FbCDDC4431177273fC7ABC",
    "5000000000000000000",
    "0xe5C1c7f074Fc2898677F778330ed3C98f6b8b66e"
  ],
  "solcInputHash": "823d00032d1bbea79db3b1c9297c243f",
  "metadata": "{\"compiler\":{\"version\":\"0.6.12+commit.27d51765\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_MASTERCHEF_V2\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"LogOnReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"}],\"name\":\"LogPoolAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"}],\"name\":\"LogSetPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"lastRewardBlock\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accRewardPerShare\",\"type\":\"uint256\"}],\"name\":\"LogUpdatePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pids\",\"type\":\"uint256[]\"}],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpToken\",\"type\":\"uint256\"}],\"name\":\"onTokenReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingTokens\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"rewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"accRewardPerShare\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"lastRewardBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"allocPoint\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pools\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direct\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"renounce\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"accRewardPerShare\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"lastRewardBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"allocPoint\",\"type\":\"uint64\"}],\"internalType\":\"struct ComplexRewarder.PoolInfo\",\"name\":\"pool\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"@0xKeno\",\"kind\":\"dev\",\"methods\":{\"add(uint256,uint256)\":{\"params\":{\"_pid\":\"Pid on MCV2\",\"allocPoint\":\"AP of the new pool.\"}},\"massUpdatePools(uint256[])\":{\"params\":{\"pids\":\"Pool IDs of all to be updated. Make sure to update all active pools.\"}},\"pendingToken(uint256,address)\":{\"params\":{\"_pid\":\"The index of the pool. See `poolInfo`.\",\"_user\":\"Address of user.\"},\"returns\":{\"pending\":\"REWARD reward for a given user.\"}},\"set(uint256,uint256)\":{\"params\":{\"_allocPoint\":\"New AP of the pool.\",\"_pid\":\"The index of the pool. See `poolInfo`.\"}},\"updatePool(uint256)\":{\"params\":{\"pid\":\"The index of the pool. See `poolInfo`.\"},\"returns\":{\"pool\":\"Returns the pool that was updated.\"}}},\"stateVariables\":{\"totalAllocPoint\":{\"details\":\"Total allocation points. Must be the sum of all allocation points in all pools.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"add(uint256,uint256)\":{\"notice\":\"Add a new LP to the pool.  Can only be called by the owner. DO NOT add the same LP token more than once. Rewards will be messed up if you do.\"},\"massUpdatePools(uint256[])\":{\"notice\":\"Update reward variables for all pools. Be careful of gas spending!\"},\"pendingToken(uint256,address)\":{\"notice\":\"View function to see pending Token\"},\"poolInfo(uint256)\":{\"notice\":\"Info of each pool.\"},\"poolLength()\":{\"notice\":\"Returns the number of MCV2 pools.\"},\"set(uint256,uint256)\":{\"notice\":\"Update the given pool's REWARD allocation point and `IRewarder` contract. Can only be called by the owner.\"},\"updatePool(uint256)\":{\"notice\":\"Update reward variables of the given pool.\"},\"userInfo(uint256,address)\":{\"notice\":\"Info of each user that stakes LP tokens.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/mocks/ComplexRewarder.sol\":\"ComplexRewarder\"},\"evmVersion\":\"istanbul\",\"libraries\":{\"__CACHE_BREAKER__\":\"0x00000000d41867734bbee4c6863d9255b2b06ac1\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@boringcrypto/boring-solidity/contracts/BoringBatchable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\\n\\n// P1 - P3: OK\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n// solhint-disable avoid-low-level-calls\\n\\nimport \\\"./libraries/BoringERC20.sol\\\";\\n\\n// T1 - T4: OK\\ncontract BaseBoringBatchable {\\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\\n        if (_returnData.length < 68) return \\\"Transaction reverted silently\\\";\\n\\n        assembly {\\n            // Slice the sighash.\\n            _returnData := add(_returnData, 0x04)\\n        }\\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\\n    }    \\n    \\n    // F3 - F9: OK\\n    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\\n    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\\n    // C1 - C21: OK\\n    // C3: The length of the loop is fully under user control, so can't be exploited\\n    // C7: Delegatecall is only used on the same contract, so it's safe\\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns(bool[] memory successes, bytes[] memory results) {\\n        // Interactions\\n        successes = new bool[](calls.length);\\n        results = new bytes[](calls.length);\\n        for (uint256 i = 0; i < calls.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\\n            require(success || !revertOnFail, _getRevertMsg(result));\\n            successes[i] = success;\\n            results[i] = result;\\n        }\\n    }\\n}\\n\\n// T1 - T4: OK\\ncontract BoringBatchable is BaseBoringBatchable {\\n    // F1 - F9: OK\\n    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)\\n    //     if part of a batch this could be used to grief once as the second call would not need the permit\\n    // C1 - C21: OK\\n    function permitToken(IERC20 token, address from, address to, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n        // Interactions\\n        // X1 - X5\\n        token.permit(from, to, amount, deadline, v, r, s);\\n    }\\n}\",\"keccak256\":\"0xab938b3b1b3328f8fbabee16c5481f021ebc581a2176b2ce2a2aedc66f9da293\",\"license\":\"UNLICENSED\"},\"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\\n\\n// P1 - P3: OK\\npragma solidity 0.6.12;\\n\\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\\n// Edited by BoringCrypto\\n\\n// T1 - T4: OK\\ncontract BoringOwnableData {\\n    // V1 - V5: OK\\n    address public owner;\\n    // V1 - V5: OK\\n    address public pendingOwner;\\n}\\n\\n// T1 - T4: OK\\ncontract BoringOwnable is BoringOwnableData {\\n    // E1: OK\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () public {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), msg.sender);\\n    }\\n\\n    // F1 - F9: OK\\n    // C1 - C21: OK\\n    function transferOwnership(address newOwner, bool direct, bool renounce) public onlyOwner {\\n        if (direct) {\\n            // Checks\\n            require(newOwner != address(0) || renounce, \\\"Ownable: zero address\\\");\\n\\n            // Effects\\n            emit OwnershipTransferred(owner, newOwner);\\n            owner = newOwner;\\n            pendingOwner = address(0);\\n        } else {\\n            // Effects\\n            pendingOwner = newOwner;\\n        }\\n    }\\n\\n    // F1 - F9: OK\\n    // C1 - C21: OK\\n    function claimOwnership() public {\\n        address _pendingOwner = pendingOwner;\\n        \\n        // Checks\\n        require(msg.sender == _pendingOwner, \\\"Ownable: caller != pending owner\\\");\\n\\n        // Effects\\n        emit OwnershipTransferred(owner, _pendingOwner);\\n        owner = _pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n\\n    // M1 - M5: OK\\n    // C1 - C21: OK\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n}\",\"keccak256\":\"0x5ee0d5606a9dd683203a34ecde9ea08e4e5ffd3ae2c0ea16d94192cac0db94e3\",\"license\":\"MIT\"},\"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    // EIP 2612\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\",\"keccak256\":\"0xbc2bbe46ffb84b39aa0e39c925b071e3a2ce6e912f7f216619550a38bbf0f9b3\",\"license\":\"MIT\"},\"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.6.12;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\nlibrary BoringERC20 {\\n    function safeSymbol(IERC20 token) internal view returns(string memory) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\n    }\\n\\n    function safeName(IERC20 token) internal view returns(string memory) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\n    }\\n\\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\\n    }\\n\\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BoringERC20: Transfer failed\\\");\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, to, amount));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BoringERC20: TransferFrom failed\\\");\\n    }\\n}\",\"keccak256\":\"0x74e55a994e33a3d6ca777c4adbd573b5427e33030c1e8603dc09f07b5f4d0a51\",\"license\":\"UNLICENSED\"},\"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n// a library for performing overflow-safe math, updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math)\\nlibrary BoringMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {require(b == 0 || (c = a * b)/b == a, \\\"BoringMath: Mul Overflow\\\");}\\n    function to128(uint256 a) internal pure returns (uint128 c) {\\n        require(a <= uint128(-1), \\\"BoringMath: uint128 Overflow\\\");\\n        c = uint128(a);\\n    }\\n    function to64(uint256 a) internal pure returns (uint64 c) {\\n        require(a <= uint64(-1), \\\"BoringMath: uint64 Overflow\\\");\\n        c = uint64(a);\\n    }\\n    function to32(uint256 a) internal pure returns (uint32 c) {\\n        require(a <= uint32(-1), \\\"BoringMath: uint32 Overflow\\\");\\n        c = uint32(a);\\n    }\\n}\\n\\nlibrary BoringMath128 {\\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\n}\\n\\nlibrary BoringMath64 {\\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\n}\\n\\nlibrary BoringMath32 {\\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {require((c = a + b) >= b, \\\"BoringMath: Add Overflow\\\");}\\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {require((c = a - b) <= a, \\\"BoringMath: Underflow\\\");}\\n}\",\"keccak256\":\"0x697187e610e3fb6d83cbb7a21d3207acd587fee596efde089e48e159ff29687e\",\"license\":\"MIT\"},\"contracts/MasterChefV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\\\";\\nimport \\\"@boringcrypto/boring-solidity/contracts/BoringBatchable.sol\\\";\\nimport \\\"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\\\";\\nimport \\\"./libraries/SignedSafeMath.sol\\\";\\nimport \\\"./interfaces/IRewarder.sol\\\";\\nimport \\\"./interfaces/IMasterChef.sol\\\";\\n\\ninterface IMigratorChef {\\n    // Take the current LP token address and return the new LP token address.\\n    // Migrator should have full access to the caller's LP token.\\n    function migrate(IERC20 token) external returns (IERC20);\\n}\\n\\n/// @notice The (older) MasterChef contract gives out a constant number of REWARD tokens per block.\\n/// It is the only address with minting rights for REWARD.\\n/// The idea for this MasterChef V2 (MCV2) contract is therefore to be the owner of a dummy token\\n/// that is deposited into the MasterChef V1 (MCV1) contract.\\n/// The allocation point for this pool on MCV1 is the total allocation point for all pools that receive double incentives.\\ncontract MasterChefV2 is BoringOwnable, BoringBatchable {\\n    using BoringMath for uint256;\\n    using BoringMath128 for uint128;\\n    using BoringERC20 for IERC20;\\n    using SignedSafeMath for int256;\\n\\n    /// @notice Info of each MCV2 user.\\n    /// `amount` LP token amount the user has provided.\\n    /// `rewardDebt` The amount of REWARD entitled to the user.\\n    struct UserInfo {\\n        uint256 amount;\\n        int256 rewardDebt;\\n    }\\n\\n    /// @notice Info of each MCV2 pool.\\n    /// `allocPoint` The amount of allocation points assigned to the pool.\\n    /// Also known as the amount of REWARD to distribute per block.\\n    struct PoolInfo {\\n        uint128 accRewardPerShare;\\n        uint64 lastRewardBlock;\\n        uint64 allocPoint;\\n    }\\n\\n    /// @notice Address of MCV1 contract.\\n    IMasterChef public immutable MASTER_CHEF;\\n    /// @notice Address of REWARD contract.\\n    IERC20 public immutable REWARD;\\n    /// @notice The index of MCV2 master pool in MCV1.\\n    uint256 public immutable MASTER_PID;\\n    // @notice The migrator contract. It has a lot of power. Can only be set through governance (owner).\\n    IMigratorChef public migrator;\\n\\n    /// @notice Info of each MCV2 pool.\\n    PoolInfo[] public poolInfo;\\n    /// @notice Address of the LP token for each MCV2 pool.\\n    IERC20[] public lpToken;\\n    /// @notice Address of each `IRewarder` contract in MCV2.\\n    IRewarder[] public rewarder;\\n\\n    /// @notice Info of each user that stakes LP tokens.\\n    mapping (uint256 => mapping (address => UserInfo)) public userInfo;\\n    /// @dev Total allocation points. Must be the sum of all allocation points in all pools.\\n    uint256 public totalAllocPoint;\\n\\n    uint256 private constant MASTERCHEF_REWARD_PER_BLOCK = 1e20;\\n    uint256 private constant ACC_REWARD_PRECISION = 1e12;\\n\\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\\n    event Harvest(address indexed user, uint256 indexed pid, uint256 amount);\\n    event LogPoolAddition(uint256 indexed pid, uint256 allocPoint, IERC20 indexed lpToken, IRewarder indexed rewarder);\\n    event LogSetPool(uint256 indexed pid, uint256 allocPoint, IRewarder indexed rewarder, bool overwrite);\\n    event LogUpdatePool(uint256 indexed pid, uint64 lastRewardBlock, uint256 lpSupply, uint256 accRewardPerShare);\\n    event LogInit();\\n\\n    /// @param _MASTER_CHEF The AMMSwap MCV1 contract address.\\n    /// @param _reward The REWARD token contract address.\\n    /// @param _MASTER_PID The pool ID of the dummy token on the base MCV1 contract.\\n    constructor(IMasterChef _MASTER_CHEF, IERC20 _reward, uint256 _MASTER_PID) public {\\n        MASTER_CHEF = _MASTER_CHEF;\\n        REWARD = _reward;\\n        MASTER_PID = _MASTER_PID;\\n    }\\n\\n    /// @notice Deposits a dummy token to `MASTER_CHEF` MCV1. This is required because MCV1 holds the minting rights for REWARD.\\n    /// Any balance of transaction sender in `dummyToken` is transferred.\\n    /// The allocation point for the pool on MCV1 is the total allocation point for all pools that receive double incentives.\\n    /// @param dummyToken The address of the ERC-20 token to deposit into MCV1.\\n    function init(IERC20 dummyToken) external {\\n        uint256 balance = dummyToken.balanceOf(msg.sender);\\n        require(balance != 0, \\\"MasterChefV2: Balance must exceed 0\\\");\\n        dummyToken.safeTransferFrom(msg.sender, address(this), balance);\\n        dummyToken.approve(address(MASTER_CHEF), balance);\\n        MASTER_CHEF.deposit(MASTER_PID, balance);\\n        emit LogInit();\\n    }\\n\\n    /// @notice Returns the number of MCV2 pools.\\n    function poolLength() public view returns (uint256 pools) {\\n        pools = poolInfo.length;\\n    }\\n\\n    /// @notice Add a new LP to the pool. Can only be called by the owner.\\n    /// DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n    /// @param allocPoint AP of the new pool.\\n    /// @param _lpToken Address of the LP ERC-20 token.\\n    /// @param _rewarder Address of the rewarder delegate.\\n    function add(uint256 allocPoint, IERC20 _lpToken, IRewarder _rewarder) public onlyOwner {\\n        uint256 lastRewardBlock = block.number;\\n        totalAllocPoint = totalAllocPoint.add(allocPoint);\\n        lpToken.push(_lpToken);\\n        rewarder.push(_rewarder);\\n\\n        poolInfo.push(PoolInfo({\\n            allocPoint: allocPoint.to64(),\\n            lastRewardBlock: lastRewardBlock.to64(),\\n            accRewardPerShare: 0\\n        }));\\n        emit LogPoolAddition(lpToken.length.sub(1), allocPoint, _lpToken, _rewarder);\\n    }\\n\\n    /// @notice Update the given pool's REWARD allocation point and `IRewarder` contract. Can only be called by the owner.\\n    /// @param _pid The index of the pool. See `poolInfo`.\\n    /// @param _allocPoint New AP of the pool.\\n    /// @param _rewarder Address of the rewarder delegate.\\n    /// @param overwrite True if _rewarder should be `set`. Otherwise `_rewarder` is ignored.\\n    function set(uint256 _pid, uint256 _allocPoint, IRewarder _rewarder, bool overwrite) public onlyOwner {\\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\\n        poolInfo[_pid].allocPoint = _allocPoint.to64();\\n        if (overwrite) { rewarder[_pid] = _rewarder; }\\n        emit LogSetPool(_pid, _allocPoint, overwrite ? _rewarder : rewarder[_pid], overwrite);\\n    }\\n\\n    /// @notice Set the `migrator` contract. Can only be called by the owner.\\n    /// @param _migrator The contract address to set.\\n    function setMigrator(IMigratorChef _migrator) public onlyOwner {\\n        migrator = _migrator;\\n    }\\n\\n    /// @notice Migrate LP token to another LP contract through the `migrator` contract.\\n    /// @param _pid The index of the pool. See `poolInfo`.\\n    function migrate(uint256 _pid) public {\\n        require(address(migrator) != address(0), \\\"MasterChefV2: no migrator set\\\");\\n        IERC20 _lpToken = lpToken[_pid];\\n        uint256 bal = _lpToken.balanceOf(address(this));\\n        _lpToken.approve(address(migrator), bal);\\n        IERC20 newLpToken = migrator.migrate(_lpToken);\\n        require(bal == newLpToken.balanceOf(address(this)), \\\"MasterChefV2: migrated balance must match\\\");\\n        lpToken[_pid] = newLpToken;\\n    }\\n\\n    /// @notice View function to see pending REWARD on frontend.\\n    /// @param _pid The index of the pool. See `poolInfo`.\\n    /// @param _user Address of user.\\n    /// @return pending REWARD reward for a given user.\\n    function pendingReward(uint256 _pid, address _user) external view returns (uint256 pending) {\\n        PoolInfo memory pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 accRewardPerShare = pool.accRewardPerShare;\\n        uint256 lpSupply = lpToken[_pid].balanceOf(address(this));\\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\\n            uint256 blocks = block.number.sub(pool.lastRewardBlock);\\n            uint256 tokenReward = blocks.mul(rewardPerBlock()).mul(pool.allocPoint) / totalAllocPoint;\\n            accRewardPerShare = accRewardPerShare.add(tokenReward.mul(ACC_REWARD_PRECISION) / lpSupply);\\n        }\\n        pending = int256(user.amount.mul(accRewardPerShare) / ACC_REWARD_PRECISION).sub(user.rewardDebt).toUInt256();\\n    }\\n\\n    /// @notice Update reward variables for all pools. Be careful of gas spending!\\n    /// @param pids Pool IDs of all to be updated. Make sure to update all active pools.\\n    function massUpdatePools(uint256[] calldata pids) external {\\n        uint256 len = pids.length;\\n        for (uint256 i = 0; i < len; ++i) {\\n            updatePool(pids[i]);\\n        }\\n    }\\n\\n    /// @notice Calculates and returns the `amount` of REWARD per block.\\n    function rewardPerBlock() public view returns (uint256 amount) {\\n        amount = uint256(MASTERCHEF_REWARD_PER_BLOCK)\\n            .mul(MASTER_CHEF.poolInfo(MASTER_PID).allocPoint) / MASTER_CHEF.totalAllocPoint();\\n    }\\n\\n    /// @notice Update reward variables of the given pool.\\n    /// @param pid The index of the pool. See `poolInfo`.\\n    /// @return pool Returns the pool that was updated.\\n    function updatePool(uint256 pid) public returns (PoolInfo memory pool) {\\n        pool = poolInfo[pid];\\n        if (block.number > pool.lastRewardBlock) {\\n            uint256 lpSupply = lpToken[pid].balanceOf(address(this));\\n            if (lpSupply > 0) {\\n                uint256 blocks = block.number.sub(pool.lastRewardBlock);\\n                uint256 tokenReward = blocks.mul(rewardPerBlock()).mul(pool.allocPoint) / totalAllocPoint;\\n                pool.accRewardPerShare = pool.accRewardPerShare.add((tokenReward.mul(ACC_REWARD_PRECISION) / lpSupply).to128());\\n            }\\n            pool.lastRewardBlock = block.number.to64();\\n            poolInfo[pid] = pool;\\n            emit LogUpdatePool(pid, pool.lastRewardBlock, lpSupply, pool.accRewardPerShare);\\n        }\\n    }\\n\\n    /// @notice Deposit LP tokens to MCV2 for REWARD allocation.\\n    /// @param pid The index of the pool. See `poolInfo`.\\n    /// @param amount LP token amount to deposit.\\n    /// @param to The receiver of `amount` deposit benefit.\\n    function deposit(uint256 pid, uint256 amount, address to) public {\\n        PoolInfo memory pool = updatePool(pid);\\n        UserInfo storage user = userInfo[pid][to];\\n\\n        // Effects\\n        user.amount = user.amount.add(amount);\\n        user.rewardDebt = user.rewardDebt.add(int256(amount.mul(pool.accRewardPerShare) / ACC_REWARD_PRECISION));\\n\\n        // Interactions\\n        IRewarder _rewarder = rewarder[pid];\\n        if (address(_rewarder) != address(0)) {\\n            _rewarder.onTokenReward(pid, to, to, 0, user.amount);\\n        }\\n\\n        lpToken[pid].safeTransferFrom(msg.sender, address(this), amount);\\n\\n        emit Deposit(msg.sender, pid, amount, to);\\n    }\\n\\n    /// @notice Withdraw LP tokens from MCV2.\\n    /// @param pid The index of the pool. See `poolInfo`.\\n    /// @param amount LP token amount to withdraw.\\n    /// @param to Receiver of the LP tokens.\\n    function withdraw(uint256 pid, uint256 amount, address to) public {\\n        PoolInfo memory pool = updatePool(pid);\\n        UserInfo storage user = userInfo[pid][msg.sender];\\n\\n        // Effects\\n        user.rewardDebt = user.rewardDebt.sub(int256(amount.mul(pool.accRewardPerShare) / ACC_REWARD_PRECISION));\\n        user.amount = user.amount.sub(amount);\\n\\n        // Interactions\\n        IRewarder _rewarder = rewarder[pid];\\n        if (address(_rewarder) != address(0)) {\\n            _rewarder.onTokenReward(pid, msg.sender, to, 0, user.amount);\\n        }\\n        \\n        lpToken[pid].safeTransfer(to, amount);\\n\\n        emit Withdraw(msg.sender, pid, amount, to);\\n    }\\n\\n    /// @notice Harvest proceeds for transaction sender to `to`.\\n    /// @param pid The index of the pool. See `poolInfo`.\\n    /// @param to Receiver of REWARD rewards.\\n    function harvest(uint256 pid, address to) public {\\n        PoolInfo memory pool = updatePool(pid);\\n        UserInfo storage user = userInfo[pid][msg.sender];\\n        int256 accumulatedReward = int256(user.amount.mul(pool.accRewardPerShare) / ACC_REWARD_PRECISION);\\n        uint256 _pendingReward = accumulatedReward.sub(user.rewardDebt).toUInt256();\\n\\n        // Effects\\n        user.rewardDebt = accumulatedReward;\\n\\n        // Interactions\\n        if (_pendingReward != 0) {\\n            REWARD.safeTransfer(to, _pendingReward);\\n        }\\n        \\n        IRewarder _rewarder = rewarder[pid];\\n        if (address(_rewarder) != address(0)) {\\n            _rewarder.onTokenReward( pid, msg.sender, to, _pendingReward, user.amount);\\n        }\\n\\n        emit Harvest(msg.sender, pid, _pendingReward);\\n    }\\n    \\n    /// @notice Withdraw LP tokens from MCV2 and harvest proceeds for transaction sender to `to`.\\n    /// @param pid The index of the pool. See `poolInfo`.\\n    /// @param amount LP token amount to withdraw.\\n    /// @param to Receiver of the LP tokens and REWARD rewards.\\n    function withdrawAndHarvest(uint256 pid, uint256 amount, address to) public {\\n        PoolInfo memory pool = updatePool(pid);\\n        UserInfo storage user = userInfo[pid][msg.sender];\\n        int256 accumulatedReward = int256(user.amount.mul(pool.accRewardPerShare) / ACC_REWARD_PRECISION);\\n        uint256 _pendingReward = accumulatedReward.sub(user.rewardDebt).toUInt256();\\n\\n        // Effects\\n        user.rewardDebt = accumulatedReward.sub(int256(amount.mul(pool.accRewardPerShare) / ACC_REWARD_PRECISION));\\n        user.amount = user.amount.sub(amount);\\n        \\n        // Interactions\\n        REWARD.safeTransfer(to, _pendingReward);\\n\\n        IRewarder _rewarder = rewarder[pid];\\n        if (address(_rewarder) != address(0)) {\\n            _rewarder.onTokenReward(pid, msg.sender, to, _pendingReward, user.amount);\\n        }\\n\\n        lpToken[pid].safeTransfer(to, amount);\\n\\n        emit Withdraw(msg.sender, pid, amount, to);\\n        emit Harvest(msg.sender, pid, _pendingReward);\\n    }\\n\\n    /// @notice Harvests REWARD from `MASTER_CHEF` MCV1 and pool `MASTER_PID` to this MCV2 contract.\\n    function harvestFromMasterChef() public {\\n        MASTER_CHEF.deposit(MASTER_PID, 0);\\n    }\\n\\n    /// @notice Withdraw without caring about rewards. EMERGENCY ONLY.\\n    /// @param pid The index of the pool. See `poolInfo`.\\n    /// @param to Receiver of the LP tokens.\\n    function emergencyWithdraw(uint256 pid, address to) public {\\n        UserInfo storage user = userInfo[pid][msg.sender];\\n        uint256 amount = user.amount;\\n        user.amount = 0;\\n        user.rewardDebt = 0;\\n\\n        IRewarder _rewarder = rewarder[pid];\\n        if (address(_rewarder) != address(0)) {\\n            _rewarder.onTokenReward(pid, msg.sender, to, 0, 0);\\n        }\\n\\n        // Note: transfer can fail or succeed if `amount` is zero.\\n        lpToken[pid].safeTransfer(to, amount);\\n        emit EmergencyWithdraw(msg.sender, pid, amount, to);\\n    }\\n}\\n\",\"keccak256\":\"0x29f1b33d845bd5566e69930d89f44402889fb3aa3fc07f760aa7b8317b9adb50\",\"license\":\"MIT\"},\"contracts/interfaces/IMasterChef.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\nimport \\\"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\\\";\\n\\ninterface IMasterChef {\\n    using BoringERC20 for IERC20;\\n    struct UserInfo {\\n        uint256 amount;     // How many LP tokens the user has provided.\\n        uint256 rewardDebt; // Reward debt. See explanation below.\\n    }\\n\\n    struct PoolInfo {\\n        IERC20 lpToken;           // Address of LP token contract.\\n        uint256 allocPoint;       // How many allocation points assigned to this pool. REWARD to distribute per block.\\n        uint256 lastRewardBlock;  // Last block number that REWARD distribution occurs.\\n        uint256 accRewardPerShare; // Accumulated REWARD per share, times 1e12. See below.\\n    }\\n\\n    function poolInfo(uint256 pid) external view returns (IMasterChef.PoolInfo memory);\\n    function totalAllocPoint() external view returns (uint256);\\n    function deposit(uint256 _pid, uint256 _amount) external;\\n}\\n\",\"keccak256\":\"0x4045c751437fa55728b99713abba5310f54a8bf6368494527549f534697ff839\",\"license\":\"MIT\"},\"contracts/interfaces/IRewarder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\nimport \\\"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\\\";\\ninterface IRewarder {\\n    using BoringERC20 for IERC20;\\n    function onTokenReward(uint256 pid, address user, address recipient, uint256 rewardAmount, uint256 newLpAmount) external;\\n    function pendingTokens(uint256 pid, address user, uint256 rewardAmount) external view returns (IERC20[] memory, uint256[] memory);\\n}\\n\",\"keccak256\":\"0xceb7bea453c7d1015313f4b9b4c82f96cb81ab21719a00e75ddb008db6c2580b\",\"license\":\"MIT\"},\"contracts/libraries/SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nlibrary SignedSafeMath {\\n    int256 constant private _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function toUInt256(int256 a) internal pure returns (uint256) {\\n        require(a >= 0, \\\"Integer < 0\\\");\\n        return uint256(a);\\n    }\\n}\",\"keccak256\":\"0x4991beb21b224dfcdc3d251e0a60fdc304d4f6b699b2c35d08f3974e5b84c86a\",\"license\":\"MIT\"},\"contracts/mocks/ComplexRewarder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\nimport \\\"../interfaces/IRewarder.sol\\\";\\nimport \\\"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\\\";\\nimport \\\"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\\\";\\nimport \\\"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\\\";\\nimport \\\"../MasterChefV2.sol\\\";\\n\\n/// @author @0xKeno\\ncontract ComplexRewarder is IRewarder,  BoringOwnable{\\n    using BoringMath for uint256;\\n    using BoringMath128 for uint128;\\n    using BoringERC20 for IERC20;\\n\\n    IERC20 private immutable rewardToken;\\n\\n    /// @notice Info of each MCV2 user.\\n    /// `amount` LP token amount the user has provided.\\n    /// `rewardDebt` The amount of REWARD entitled to the user.\\n    struct UserInfo {\\n        uint256 amount;\\n        uint256 rewardDebt;\\n    }\\n\\n    /// @notice Info of each MCV2 pool.\\n    /// `allocPoint` The amount of allocation points assigned to the pool.\\n    /// Also known as the amount of REWARD to distribute per block.\\n    struct PoolInfo {\\n        uint128 accRewardPerShare;\\n        uint64 lastRewardBlock;\\n        uint64 allocPoint;\\n    }\\n\\n    /// @notice Info of each pool.\\n    mapping (uint256 => PoolInfo) public poolInfo;\\n\\n    uint256[] public poolIds;\\n\\n    /// @notice Info of each user that stakes LP tokens.\\n    mapping (uint256 => mapping (address => UserInfo)) public userInfo;\\n    /// @dev Total allocation points. Must be the sum of all allocation points in all pools.\\n    uint256 totalAllocPoint;\\n\\n    uint256 public tokenPerBlock;\\n    uint256 private constant ACC_TOKEN_PRECISION = 1e12;\\n\\n    address private immutable MASTERCHEF_V2;\\n\\n    event LogOnReward(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\\n    event LogPoolAddition(uint256 indexed pid, uint256 allocPoint);\\n    event LogSetPool(uint256 indexed pid, uint256 allocPoint);\\n    event LogUpdatePool(uint256 indexed pid, uint64 lastRewardBlock, uint256 lpSupply, uint256 accRewardPerShare);\\n    event LogInit();\\n\\n    constructor (IERC20 _rewardToken, uint256 _tokenPerBlock, address _MASTERCHEF_V2) public {\\n        rewardToken = _rewardToken;\\n        tokenPerBlock = _tokenPerBlock;\\n        MASTERCHEF_V2 = _MASTERCHEF_V2;\\n    }\\n\\n\\n    function onTokenReward (uint256 pid, address _user, address to, uint256, uint256 lpToken) onlyMCV2 override external {\\n        PoolInfo memory pool = updatePool(pid);\\n        UserInfo storage user = userInfo[pid][_user];\\n        uint256 pending;\\n        if (user.amount > 0) {\\n            pending =\\n                (user.amount.mul(pool.accRewardPerShare) / ACC_TOKEN_PRECISION).sub(\\n                    user.rewardDebt\\n                );\\n            rewardToken.safeTransfer(to, pending);\\n        }\\n        user.amount = lpToken;\\n        user.rewardDebt = lpToken.mul(pool.accRewardPerShare) / ACC_TOKEN_PRECISION;\\n        emit LogOnReward(_user, pid, pending, to);\\n    }\\n    \\n    function pendingTokens(uint256 pid, address user, uint256) override external view returns (IERC20[] memory rewardTokens, uint256[] memory rewardAmounts) {\\n        IERC20[] memory _rewardTokens = new IERC20[](1);\\n        _rewardTokens[0] = (rewardToken);\\n        uint256[] memory _rewardAmounts = new uint256[](1);\\n        _rewardAmounts[0] = pendingToken(pid, user);\\n        return (_rewardTokens, _rewardAmounts);\\n    }\\n\\n    modifier onlyMCV2 {\\n        require(\\n            msg.sender == MASTERCHEF_V2,\\n            \\\"Only MCV2 can call this function.\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @notice Returns the number of MCV2 pools.\\n    function poolLength() public view returns (uint256 pools) {\\n        pools = poolIds.length;\\n    }\\n\\n    /// @notice Add a new LP to the pool.  Can only be called by the owner.\\n    /// DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n    /// @param allocPoint AP of the new pool.\\n    /// @param _pid Pid on MCV2\\n    function add(uint256 allocPoint, uint256 _pid) public onlyOwner {\\n        require(poolInfo[_pid].lastRewardBlock == 0, \\\"Pool already exists\\\");\\n        uint256 lastRewardBlock = block.number;\\n        totalAllocPoint = totalAllocPoint.add(allocPoint);\\n\\n        poolInfo[_pid] = PoolInfo({\\n            allocPoint: allocPoint.to64(),\\n            lastRewardBlock: lastRewardBlock.to64(),\\n            accRewardPerShare: 0\\n        });\\n        poolIds.push(_pid);\\n        emit LogPoolAddition(_pid, allocPoint);\\n    }\\n\\n    /// @notice Update the given pool's REWARD allocation point and `IRewarder` contract. Can only be called by the owner.\\n    /// @param _pid The index of the pool. See `poolInfo`.\\n    /// @param _allocPoint New AP of the pool.\\n    function set(uint256 _pid, uint256 _allocPoint) public onlyOwner {\\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\\n        poolInfo[_pid].allocPoint = _allocPoint.to64();\\n        emit LogSetPool(_pid, _allocPoint);\\n    }\\n\\n    /// @notice View function to see pending Token\\n    /// @param _pid The index of the pool. See `poolInfo`.\\n    /// @param _user Address of user.\\n    /// @return pending REWARD reward for a given user.\\n    function pendingToken(uint256 _pid, address _user) public view returns (uint256 pending) {\\n        PoolInfo memory pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 accRewardPerShare = pool.accRewardPerShare;\\n        uint256 lpSupply = MasterChefV2(MASTERCHEF_V2).lpToken(_pid).balanceOf(MASTERCHEF_V2);\\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\\n            uint256 blocks = block.number.sub(pool.lastRewardBlock);\\n            uint256 tokenReward = blocks.mul(tokenPerBlock).mul(pool.allocPoint) / totalAllocPoint;\\n            accRewardPerShare = accRewardPerShare.add(tokenReward.mul(ACC_TOKEN_PRECISION) / lpSupply);\\n        }\\n        pending = (user.amount.mul(accRewardPerShare) / ACC_TOKEN_PRECISION).sub(user.rewardDebt);\\n    }\\n\\n    /// @notice Update reward variables for all pools. Be careful of gas spending!\\n    /// @param pids Pool IDs of all to be updated. Make sure to update all active pools.\\n    function massUpdatePools(uint256[] calldata pids) external {\\n        uint256 len = pids.length;\\n        for (uint256 i = 0; i < len; ++i) {\\n            updatePool(pids[i]);\\n        }\\n    }\\n\\n    /// @notice Update reward variables of the given pool.\\n    /// @param pid The index of the pool. See `poolInfo`.\\n    /// @return pool Returns the pool that was updated.\\n    function updatePool(uint256 pid) public returns (PoolInfo memory pool) {\\n        pool = poolInfo[pid];\\n        require(pool.lastRewardBlock != 0, \\\"Pool does not exist\\\");\\n        if (block.number > pool.lastRewardBlock) {\\n            uint256 lpSupply = MasterChefV2(MASTERCHEF_V2).lpToken(pid).balanceOf(MASTERCHEF_V2);\\n\\n            if (lpSupply > 0) {\\n                uint256 blocks = block.number.sub(pool.lastRewardBlock);\\n                uint256 tokenReward = blocks.mul(tokenPerBlock).mul(pool.allocPoint) / totalAllocPoint;\\n                pool.accRewardPerShare = pool.accRewardPerShare.add((tokenReward.mul(ACC_TOKEN_PRECISION) / lpSupply).to128());\\n            }\\n            pool.lastRewardBlock = block.number.to64();\\n            poolInfo[pid] = pool;\\n            emit LogUpdatePool(pid, pool.lastRewardBlock, lpSupply, pool.accRewardPerShare);\\n        }\\n    }\\n\\n}\\n\",\"keccak256\":\"0x6a5deafae7fe36115145b208a1236bc89ba6fa730d151fa5e5190c7fc8126685\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c06040523480156200001157600080fd5b50604051620018c8380380620018c8833981016040819052620000349162000099565b600080546001600160a01b0319163390811782556040519091907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a36001600160601b0319606093841b811660805260069290925590911b1660a052620000f9565b600080600060608486031215620000ae578283fd5b8351620000bb81620000e0565b602085015160408601519194509250620000d581620000e0565b809150509250925092565b6001600160a01b0381168114620000f657600080fd5b50565b60805160601c60a05160601c61178c6200013c600039806104fb5280610590528061070552806109935280610a285250806107b65280610e5d525061178c6000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c806351eb05a6116100975780638da5cb5b116100665780638da5cb5b146101fc57806393f1a40b14610211578063d63b3c4914610232578063e30c39781461025357610100565b806351eb05a6146101a357806357a5b58c146101c357806369883b4e146101d6578063771602f7146101e957610100565b80634198709a116100d35780634198709a1461016d57806348e43af4146101755780634a2f4b43146101885780634e71e0c81461019b57610100565b8063078dfbe714610105578063081e3eda1461011a5780631526fe27146101385780631ab06ee51461015a575b600080fd5b610118610113366004611119565b61025b565b005b61012261034a565b60405161012f91906116ef565b60405180910390f35b61014b610146366004611210565b610350565b60405161012f939291906116c5565b6101186101683660046112f7565b610387565b610122610466565b610122610183366004611240565b61046c565b61011861019636600461126f565b6106fa565b610118610863565b6101b66101b1366004611210565b6108f0565b60405161012f919061168c565b6101186101d1366004611163565b610c18565b6101226101e4366004611210565b610c4e565b6101186101f73660046112f7565b610c6c565b610204610e02565b60405161012f9190611359565b61022461021f366004611240565b610e11565b60405161012f9291906116f8565b6102456102403660046112c0565b610e35565b60405161012f929190611386565b610204610ef4565b6000546001600160a01b0316331461028e5760405162461bcd60e51b8152600401610285906115b4565b60405180910390fd5b8115610329576001600160a01b0383161515806102a85750805b6102c45760405162461bcd60e51b8152600401610285906114ea565b600080546040516001600160a01b03808716939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0385166001600160a01b031991821617909155600180549091169055610345565b600180546001600160a01b0319166001600160a01b0385161790555b505050565b60035490565b6002602052600090815260409020546001600160801b038116906001600160401b03600160801b8204811691600160c01b90041683565b6000546001600160a01b031633146103b15760405162461bcd60e51b8152600401610285906115b4565b6000828152600260205260409020546005546103e89183916103e291600160c01b90046001600160401b0316610f03565b90610f2c565b6005556103f481610f4f565b6000838152600260205260409081902080546001600160401b0393909316600160c01b026001600160c01b03909316929092179091555182907f942cc7e17a17c164bd977f32ab8c54265d5b9d481e4e352bf874f1e568874e7c9061045a9084906116ef565b60405180910390a25050565b60065481565b60006104766110f9565b506000838152600260209081526040808320815160608101835290546001600160801b0380821683526001600160401b03600160801b8304811684870152600160c01b9092049091168284015287855260048085528386206001600160a01b03808a1688529552838620835194516378ed5d1f60e01b815293969095949092169391927f0000000000000000000000000000000000000000000000000000000000000000909216916378ed5d1f91610530918b91016116ef565b60206040518083038186803b15801561054857600080fd5b505afa15801561055c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061058091906111f4565b6001600160a01b03166370a082317f00000000000000000000000000000000000000000000000000000000000000006040518263ffffffff1660e01b81526004016105cb9190611359565b60206040518083038186803b1580156105e357600080fd5b505afa1580156105f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061061b9190611228565b905083602001516001600160401b03164311801561063857508015155b156106c457600061065f85602001516001600160401b031643610f0390919063ffffffff16565b9050600060055461069287604001516001600160401b031661068c60065486610f7c90919063ffffffff16565b90610f7c565b8161069957fe5b0490506106bf836106af8364e8d4a51000610f7c565b816106b657fe5b86919004610f2c565b935050505b600183015483546106ef919064e8d4a51000906106e19086610f7c565b816106e857fe5b0490610f03565b979650505050505050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146107425760405162461bcd60e51b8152600401610285906114a9565b61074a6110f9565b610753866108f0565b60008781526004602090815260408083206001600160a01b038a1684529091528120805492935091156107dd576001820154835183546107a7929164e8d4a51000916106e1916001600160801b0316610f7c565b90506107dd6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168783610fb3565b838255825164e8d4a51000906107fd9086906001600160801b0316610f7c565b8161080457fe5b048260010181905550856001600160a01b031688886001600160a01b03167f2ece88ca2bc08dd018db50e1d25a20bf1241e5fab1c396caa51f01a54bd2f75b8460405161085191906116ef565b60405180910390a45050505050505050565b6001546001600160a01b031633811461088e5760405162461bcd60e51b8152600401610285906115e9565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b039092166001600160a01b0319928316179055600180549091169055565b6108f86110f9565b50600081815260026020908152604091829020825160608101845290546001600160801b03811682526001600160401b03600160801b82048116938301849052600160c01b90910416928101929092526109645760405162461bcd60e51b815260040161028590611519565b80602001516001600160401b0316431115610c13576040516378ed5d1f60e01b81526000906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906378ed5d1f906109c89086906004016116ef565b60206040518083038186803b1580156109e057600080fd5b505afa1580156109f4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a1891906111f4565b6001600160a01b03166370a082317f00000000000000000000000000000000000000000000000000000000000000006040518263ffffffff1660e01b8152600401610a639190611359565b60206040518083038186803b158015610a7b57600080fd5b505afa158015610a8f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ab39190611228565b90508015610b56576000610add83602001516001600160401b031643610f0390919063ffffffff16565b90506000600554610b0a85604001516001600160401b031661068c60065486610f7c90919063ffffffff16565b81610b1157fe5b049050610b48610b3784610b2a8464e8d4a51000610f7c565b81610b3157fe5b046110a1565b85516001600160801b0316906110ca565b6001600160801b0316845250505b610b5f43610f4f565b6001600160401b03908116602084810191825260008681526002909152604090819020855181549351838801516001600160801b03199095166001600160801b0383161767ffffffffffffffff60801b1916600160801b82881602176001600160c01b0316600160c01b95909616949094029490941790555185927f0fc9545022a542541ad085d091fb09a2ab36fee366a4576ab63714ea907ad35392610c099290918691611706565b60405180910390a2505b919050565b8060005b81811015610c4857610c3f848483818110610c3357fe5b905060200201356108f0565b50600101610c1c565b50505050565b60038181548110610c5b57fe5b600091825260209091200154905081565b6000546001600160a01b03163314610c965760405162461bcd60e51b8152600401610285906115b4565b600081815260026020526040902054600160801b90046001600160401b031615610cd25760405162461bcd60e51b815260040161028590611445565b6005544390610ce19084610f2c565b60055560408051606081019091526000815260208101610d0083610f4f565b6001600160401b03168152602001610d1785610f4f565b6001600160401b0390811690915260008481526002602090815260408083208551815493870151968301518616600160c01b026001600160c01b0397909616600160801b0267ffffffffffffffff60801b196001600160801b039092166001600160801b031990951694909417169290921794909416929092179091556003805460018101825591527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b018390555182907f38410508059921573ab9ebdca2a5034be738d236366b8f32de4434ea95ed3c8190610df59086906116ef565b60405180910390a2505050565b6000546001600160a01b031681565b60046020908152600092835260408084209091529082529020805460019091015482565b60408051600180825281830190925260609182918291602080830190803683370190505090507f000000000000000000000000000000000000000000000000000000000000000081600081518110610e8957fe5b6001600160a01b039290921660209283029190910190910152604080516001808252818301909252606091816020016020820280368337019050509050610ed0878761046c565b81600081518110610edd57fe5b602090810291909101015290969095509350505050565b6001546001600160a01b031681565b80820382811115610f265760405162461bcd60e51b815260040161028590611416565b92915050565b81810181811015610f265760405162461bcd60e51b81526004016102859061157d565b60006001600160401b03821115610f785760405162461bcd60e51b81526004016102859061161e565b5090565b6000811580610f9757505080820282828281610f9457fe5b04145b610f265760405162461bcd60e51b815260040161028590611655565b60006060846001600160a01b031663a9059cbb8585604051602401610fd992919061136d565b6040516020818303038152906040529060e01b6020820180516001600160e01b0383818316178352505050506040516110129190611320565b6000604051808303816000865af19150503d806000811461104f576040519150601f19603f3d011682016040523d82523d6000602084013e611054565b606091505b509150915081801561107e57508051158061107e57508080602001905181019061107e91906111d1565b61109a5760405162461bcd60e51b815260040161028590611472565b5050505050565b60006001600160801b03821115610f785760405162461bcd60e51b815260040161028590611546565b8181016001600160801b038083169082161015610f265760405162461bcd60e51b81526004016102859061157d565b604080516060810182526000808252602082018190529181019190915290565b60008060006060848603121561112d578283fd5b833561113881611730565b9250602084013561114881611748565b9150604084013561115881611748565b809150509250925092565b60008060208385031215611175578182fd5b82356001600160401b038082111561118b578384fd5b818501915085601f83011261119e578384fd5b8135818111156111ac578485fd5b86602080830285010111156111bf578485fd5b60209290920196919550909350505050565b6000602082840312156111e2578081fd5b81516111ed81611748565b9392505050565b600060208284031215611205578081fd5b81516111ed81611730565b600060208284031215611221578081fd5b5035919050565b600060208284031215611239578081fd5b5051919050565b60008060408385031215611252578182fd5b82359150602083013561126481611730565b809150509250929050565b600080600080600060a08688031215611286578081fd5b85359450602086013561129881611730565b935060408601356112a881611730565b94979396509394606081013594506080013592915050565b6000806000606084860312156112d4578283fd5b8335925060208401356112e681611730565b929592945050506040919091013590565b60008060408385031215611309578182fd5b50508035926020909101359150565b815260200190565b60008251815b818110156113405760208186018101518583015201611326565b8181111561134e5782828501525b509190910192915050565b6001600160a01b0391909116815260200190565b6001600160a01b03929092168252602082015260400190565b604080825283519082018190526000906020906060840190828701845b828110156113c85781516001600160a01b0316845292840192908401906001016113a3565b505050838103828501528085516113df81846116ef565b91508387019250845b81811015611409576113fb838551611318565b9385019392506001016113e8565b5090979650505050505050565b602080825260159082015274426f72696e674d6174683a20556e646572666c6f7760581b604082015260600190565b602080825260139082015272506f6f6c20616c72656164792065786973747360681b604082015260600190565b6020808252601c908201527f426f72696e6745524332303a205472616e73666572206661696c656400000000604082015260600190565b60208082526021908201527f4f6e6c79204d4356322063616e2063616c6c20746869732066756e6374696f6e6040820152601760f91b606082015260800190565b6020808252601590820152744f776e61626c653a207a65726f206164647265737360581b604082015260600190565b602080825260139082015272141bdbdb08191bd95cc81b9bdd08195e1a5cdd606a1b604082015260600190565b6020808252601c908201527f426f72696e674d6174683a2075696e74313238204f766572666c6f7700000000604082015260600190565b60208082526018908201527f426f72696e674d6174683a20416464204f766572666c6f770000000000000000604082015260600190565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b6020808252818101527f4f776e61626c653a2063616c6c657220213d2070656e64696e67206f776e6572604082015260600190565b6020808252601b908201527f426f72696e674d6174683a2075696e743634204f766572666c6f770000000000604082015260600190565b60208082526018908201527f426f72696e674d6174683a204d756c204f766572666c6f770000000000000000604082015260600190565b81516001600160801b031681526020808301516001600160401b0390811691830191909152604092830151169181019190915260600190565b6001600160801b039390931683526001600160401b03918216602084015216604082015260600190565b90815260200190565b918252602082015260400190565b6001600160401b0393909316835260208301919091526001600160801b0316604082015260600190565b6001600160a01b038116811461174557600080fd5b50565b801515811461174557600080fdfea2646970667358221220c8d19e64e9d2f9c2c11b6b82cb554c1ec1c921ee26ddd350d2d07af6c03c09cc64736f6c634300060c0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101005760003560e01c806351eb05a6116100975780638da5cb5b116100665780638da5cb5b146101fc57806393f1a40b14610211578063d63b3c4914610232578063e30c39781461025357610100565b806351eb05a6146101a357806357a5b58c146101c357806369883b4e146101d6578063771602f7146101e957610100565b80634198709a116100d35780634198709a1461016d57806348e43af4146101755780634a2f4b43146101885780634e71e0c81461019b57610100565b8063078dfbe714610105578063081e3eda1461011a5780631526fe27146101385780631ab06ee51461015a575b600080fd5b610118610113366004611119565b61025b565b005b61012261034a565b60405161012f91906116ef565b60405180910390f35b61014b610146366004611210565b610350565b60405161012f939291906116c5565b6101186101683660046112f7565b610387565b610122610466565b610122610183366004611240565b61046c565b61011861019636600461126f565b6106fa565b610118610863565b6101b66101b1366004611210565b6108f0565b60405161012f919061168c565b6101186101d1366004611163565b610c18565b6101226101e4366004611210565b610c4e565b6101186101f73660046112f7565b610c6c565b610204610e02565b60405161012f9190611359565b61022461021f366004611240565b610e11565b60405161012f9291906116f8565b6102456102403660046112c0565b610e35565b60405161012f929190611386565b610204610ef4565b6000546001600160a01b0316331461028e5760405162461bcd60e51b8152600401610285906115b4565b60405180910390fd5b8115610329576001600160a01b0383161515806102a85750805b6102c45760405162461bcd60e51b8152600401610285906114ea565b600080546040516001600160a01b03808716939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0385166001600160a01b031991821617909155600180549091169055610345565b600180546001600160a01b0319166001600160a01b0385161790555b505050565b60035490565b6002602052600090815260409020546001600160801b038116906001600160401b03600160801b8204811691600160c01b90041683565b6000546001600160a01b031633146103b15760405162461bcd60e51b8152600401610285906115b4565b6000828152600260205260409020546005546103e89183916103e291600160c01b90046001600160401b0316610f03565b90610f2c565b6005556103f481610f4f565b6000838152600260205260409081902080546001600160401b0393909316600160c01b026001600160c01b03909316929092179091555182907f942cc7e17a17c164bd977f32ab8c54265d5b9d481e4e352bf874f1e568874e7c9061045a9084906116ef565b60405180910390a25050565b60065481565b60006104766110f9565b506000838152600260209081526040808320815160608101835290546001600160801b0380821683526001600160401b03600160801b8304811684870152600160c01b9092049091168284015287855260048085528386206001600160a01b03808a1688529552838620835194516378ed5d1f60e01b815293969095949092169391927f0000000000000000000000000000000000000000000000000000000000000000909216916378ed5d1f91610530918b91016116ef565b60206040518083038186803b15801561054857600080fd5b505afa15801561055c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061058091906111f4565b6001600160a01b03166370a082317f00000000000000000000000000000000000000000000000000000000000000006040518263ffffffff1660e01b81526004016105cb9190611359565b60206040518083038186803b1580156105e357600080fd5b505afa1580156105f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061061b9190611228565b905083602001516001600160401b03164311801561063857508015155b156106c457600061065f85602001516001600160401b031643610f0390919063ffffffff16565b9050600060055461069287604001516001600160401b031661068c60065486610f7c90919063ffffffff16565b90610f7c565b8161069957fe5b0490506106bf836106af8364e8d4a51000610f7c565b816106b657fe5b86919004610f2c565b935050505b600183015483546106ef919064e8d4a51000906106e19086610f7c565b816106e857fe5b0490610f03565b979650505050505050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146107425760405162461bcd60e51b8152600401610285906114a9565b61074a6110f9565b610753866108f0565b60008781526004602090815260408083206001600160a01b038a1684529091528120805492935091156107dd576001820154835183546107a7929164e8d4a51000916106e1916001600160801b0316610f7c565b90506107dd6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168783610fb3565b838255825164e8d4a51000906107fd9086906001600160801b0316610f7c565b8161080457fe5b048260010181905550856001600160a01b031688886001600160a01b03167f2ece88ca2bc08dd018db50e1d25a20bf1241e5fab1c396caa51f01a54bd2f75b8460405161085191906116ef565b60405180910390a45050505050505050565b6001546001600160a01b031633811461088e5760405162461bcd60e51b8152600401610285906115e9565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b039092166001600160a01b0319928316179055600180549091169055565b6108f86110f9565b50600081815260026020908152604091829020825160608101845290546001600160801b03811682526001600160401b03600160801b82048116938301849052600160c01b90910416928101929092526109645760405162461bcd60e51b815260040161028590611519565b80602001516001600160401b0316431115610c13576040516378ed5d1f60e01b81526000906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906378ed5d1f906109c89086906004016116ef565b60206040518083038186803b1580156109e057600080fd5b505afa1580156109f4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a1891906111f4565b6001600160a01b03166370a082317f00000000000000000000000000000000000000000000000000000000000000006040518263ffffffff1660e01b8152600401610a639190611359565b60206040518083038186803b158015610a7b57600080fd5b505afa158015610a8f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ab39190611228565b90508015610b56576000610add83602001516001600160401b031643610f0390919063ffffffff16565b90506000600554610b0a85604001516001600160401b031661068c60065486610f7c90919063ffffffff16565b81610b1157fe5b049050610b48610b3784610b2a8464e8d4a51000610f7c565b81610b3157fe5b046110a1565b85516001600160801b0316906110ca565b6001600160801b0316845250505b610b5f43610f4f565b6001600160401b03908116602084810191825260008681526002909152604090819020855181549351838801516001600160801b03199095166001600160801b0383161767ffffffffffffffff60801b1916600160801b82881602176001600160c01b0316600160c01b95909616949094029490941790555185927f0fc9545022a542541ad085d091fb09a2ab36fee366a4576ab63714ea907ad35392610c099290918691611706565b60405180910390a2505b919050565b8060005b81811015610c4857610c3f848483818110610c3357fe5b905060200201356108f0565b50600101610c1c565b50505050565b60038181548110610c5b57fe5b600091825260209091200154905081565b6000546001600160a01b03163314610c965760405162461bcd60e51b8152600401610285906115b4565b600081815260026020526040902054600160801b90046001600160401b031615610cd25760405162461bcd60e51b815260040161028590611445565b6005544390610ce19084610f2c565b60055560408051606081019091526000815260208101610d0083610f4f565b6001600160401b03168152602001610d1785610f4f565b6001600160401b0390811690915260008481526002602090815260408083208551815493870151968301518616600160c01b026001600160c01b0397909616600160801b0267ffffffffffffffff60801b196001600160801b039092166001600160801b031990951694909417169290921794909416929092179091556003805460018101825591527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b018390555182907f38410508059921573ab9ebdca2a5034be738d236366b8f32de4434ea95ed3c8190610df59086906116ef565b60405180910390a2505050565b6000546001600160a01b031681565b60046020908152600092835260408084209091529082529020805460019091015482565b60408051600180825281830190925260609182918291602080830190803683370190505090507f000000000000000000000000000000000000000000000000000000000000000081600081518110610e8957fe5b6001600160a01b039290921660209283029190910190910152604080516001808252818301909252606091816020016020820280368337019050509050610ed0878761046c565b81600081518110610edd57fe5b602090810291909101015290969095509350505050565b6001546001600160a01b031681565b80820382811115610f265760405162461bcd60e51b815260040161028590611416565b92915050565b81810181811015610f265760405162461bcd60e51b81526004016102859061157d565b60006001600160401b03821115610f785760405162461bcd60e51b81526004016102859061161e565b5090565b6000811580610f9757505080820282828281610f9457fe5b04145b610f265760405162461bcd60e51b815260040161028590611655565b60006060846001600160a01b031663a9059cbb8585604051602401610fd992919061136d565b6040516020818303038152906040529060e01b6020820180516001600160e01b0383818316178352505050506040516110129190611320565b6000604051808303816000865af19150503d806000811461104f576040519150601f19603f3d011682016040523d82523d6000602084013e611054565b606091505b509150915081801561107e57508051158061107e57508080602001905181019061107e91906111d1565b61109a5760405162461bcd60e51b815260040161028590611472565b5050505050565b60006001600160801b03821115610f785760405162461bcd60e51b815260040161028590611546565b8181016001600160801b038083169082161015610f265760405162461bcd60e51b81526004016102859061157d565b604080516060810182526000808252602082018190529181019190915290565b60008060006060848603121561112d578283fd5b833561113881611730565b9250602084013561114881611748565b9150604084013561115881611748565b809150509250925092565b60008060208385031215611175578182fd5b82356001600160401b038082111561118b578384fd5b818501915085601f83011261119e578384fd5b8135818111156111ac578485fd5b86602080830285010111156111bf578485fd5b60209290920196919550909350505050565b6000602082840312156111e2578081fd5b81516111ed81611748565b9392505050565b600060208284031215611205578081fd5b81516111ed81611730565b600060208284031215611221578081fd5b5035919050565b600060208284031215611239578081fd5b5051919050565b60008060408385031215611252578182fd5b82359150602083013561126481611730565b809150509250929050565b600080600080600060a08688031215611286578081fd5b85359450602086013561129881611730565b935060408601356112a881611730565b94979396509394606081013594506080013592915050565b6000806000606084860312156112d4578283fd5b8335925060208401356112e681611730565b929592945050506040919091013590565b60008060408385031215611309578182fd5b50508035926020909101359150565b815260200190565b60008251815b818110156113405760208186018101518583015201611326565b8181111561134e5782828501525b509190910192915050565b6001600160a01b0391909116815260200190565b6001600160a01b03929092168252602082015260400190565b604080825283519082018190526000906020906060840190828701845b828110156113c85781516001600160a01b0316845292840192908401906001016113a3565b505050838103828501528085516113df81846116ef565b91508387019250845b81811015611409576113fb838551611318565b9385019392506001016113e8565b5090979650505050505050565b602080825260159082015274426f72696e674d6174683a20556e646572666c6f7760581b604082015260600190565b602080825260139082015272506f6f6c20616c72656164792065786973747360681b604082015260600190565b6020808252601c908201527f426f72696e6745524332303a205472616e73666572206661696c656400000000604082015260600190565b60208082526021908201527f4f6e6c79204d4356322063616e2063616c6c20746869732066756e6374696f6e6040820152601760f91b606082015260800190565b6020808252601590820152744f776e61626c653a207a65726f206164647265737360581b604082015260600190565b602080825260139082015272141bdbdb08191bd95cc81b9bdd08195e1a5cdd606a1b604082015260600190565b6020808252601c908201527f426f72696e674d6174683a2075696e74313238204f766572666c6f7700000000604082015260600190565b60208082526018908201527f426f72696e674d6174683a20416464204f766572666c6f770000000000000000604082015260600190565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b6020808252818101527f4f776e61626c653a2063616c6c657220213d2070656e64696e67206f776e6572604082015260600190565b6020808252601b908201527f426f72696e674d6174683a2075696e743634204f766572666c6f770000000000604082015260600190565b60208082526018908201527f426f72696e674d6174683a204d756c204f766572666c6f770000000000000000604082015260600190565b81516001600160801b031681526020808301516001600160401b0390811691830191909152604092830151169181019190915260600190565b6001600160801b039390931683526001600160401b03918216602084015216604082015260600190565b90815260200190565b918252602082015260400190565b6001600160401b0393909316835260208301919091526001600160801b0316604082015260600190565b6001600160a01b038116811461174557600080fd5b50565b801515811461174557600080fdfea2646970667358221220c8d19e64e9d2f9c2c11b6b82cb554c1ec1c921ee26ddd350d2d07af6c03c09cc64736f6c634300060c0033",
  "devdoc": {
    "author": "@0xKeno",
    "kind": "dev",
    "methods": {
      "add(uint256,uint256)": {
        "params": {
          "_pid": "Pid on MCV2",
          "allocPoint": "AP of the new pool."
        }
      },
      "massUpdatePools(uint256[])": {
        "params": {
          "pids": "Pool IDs of all to be updated. Make sure to update all active pools."
        }
      },
      "pendingToken(uint256,address)": {
        "params": {
          "_pid": "The index of the pool. See `poolInfo`.",
          "_user": "Address of user."
        },
        "returns": {
          "pending": "REWARD reward for a given user."
        }
      },
      "set(uint256,uint256)": {
        "params": {
          "_allocPoint": "New AP of the pool.",
          "_pid": "The index of the pool. See `poolInfo`."
        }
      },
      "updatePool(uint256)": {
        "params": {
          "pid": "The index of the pool. See `poolInfo`."
        },
        "returns": {
          "pool": "Returns the pool that was updated."
        }
      }
    },
    "stateVariables": {
      "totalAllocPoint": {
        "details": "Total allocation points. Must be the sum of all allocation points in all pools."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "add(uint256,uint256)": {
        "notice": "Add a new LP to the pool.  Can only be called by the owner. DO NOT add the same LP token more than once. Rewards will be messed up if you do."
      },
      "massUpdatePools(uint256[])": {
        "notice": "Update reward variables for all pools. Be careful of gas spending!"
      },
      "pendingToken(uint256,address)": {
        "notice": "View function to see pending Token"
      },
      "poolInfo(uint256)": {
        "notice": "Info of each pool."
      },
      "poolLength()": {
        "notice": "Returns the number of MCV2 pools."
      },
      "set(uint256,uint256)": {
        "notice": "Update the given pool's REWARD allocation point and `IRewarder` contract. Can only be called by the owner."
      },
      "updatePool(uint256)": {
        "notice": "Update reward variables of the given pool."
      },
      "userInfo(uint256,address)": {
        "notice": "Info of each user that stakes LP tokens."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 149,
        "contract": "contracts/mocks/ComplexRewarder.sol:ComplexRewarder",
        "label": "owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 151,
        "contract": "contracts/mocks/ComplexRewarder.sol:ComplexRewarder",
        "label": "pendingOwner",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 3585,
        "contract": "contracts/mocks/ComplexRewarder.sol:ComplexRewarder",
        "label": "poolInfo",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint256,t_struct(PoolInfo)3580_storage)"
      },
      {
        "astId": 3588,
        "contract": "contracts/mocks/ComplexRewarder.sol:ComplexRewarder",
        "label": "poolIds",
        "offset": 0,
        "slot": "3",
        "type": "t_array(t_uint256)dyn_storage"
      },
      {
        "astId": 3595,
        "contract": "contracts/mocks/ComplexRewarder.sol:ComplexRewarder",
        "label": "userInfo",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_uint256,t_mapping(t_address,t_struct(UserInfo)3573_storage))"
      },
      {
        "astId": 3598,
        "contract": "contracts/mocks/ComplexRewarder.sol:ComplexRewarder",
        "label": "totalAllocPoint",
        "offset": 0,
        "slot": "5",
        "type": "t_uint256"
      },
      {
        "astId": 3600,
        "contract": "contracts/mocks/ComplexRewarder.sol:ComplexRewarder",
        "label": "tokenPerBlock",
        "offset": 0,
        "slot": "6",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_struct(UserInfo)3573_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct ComplexRewarder.UserInfo)",
        "numberOfBytes": "32",
        "value": "t_struct(UserInfo)3573_storage"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_struct(UserInfo)3573_storage))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => struct ComplexRewarder.UserInfo))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_struct(UserInfo)3573_storage)"
      },
      "t_mapping(t_uint256,t_struct(PoolInfo)3580_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ComplexRewarder.PoolInfo)",
        "numberOfBytes": "32",
        "value": "t_struct(PoolInfo)3580_storage"
      },
      "t_struct(PoolInfo)3580_storage": {
        "encoding": "inplace",
        "label": "struct ComplexRewarder.PoolInfo",
        "members": [
          {
            "astId": 3575,
            "contract": "contracts/mocks/ComplexRewarder.sol:ComplexRewarder",
            "label": "accRewardPerShare",
            "offset": 0,
            "slot": "0",
            "type": "t_uint128"
          },
          {
            "astId": 3577,
            "contract": "contracts/mocks/ComplexRewarder.sol:ComplexRewarder",
            "label": "lastRewardBlock",
            "offset": 16,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 3579,
            "contract": "contracts/mocks/ComplexRewarder.sol:ComplexRewarder",
            "label": "allocPoint",
            "offset": 24,
            "slot": "0",
            "type": "t_uint64"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(UserInfo)3573_storage": {
        "encoding": "inplace",
        "label": "struct ComplexRewarder.UserInfo",
        "members": [
          {
            "astId": 3570,
            "contract": "contracts/mocks/ComplexRewarder.sol:ComplexRewarder",
            "label": "amount",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 3572,
            "contract": "contracts/mocks/ComplexRewarder.sol:ComplexRewarder",
            "label": "rewardDebt",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}